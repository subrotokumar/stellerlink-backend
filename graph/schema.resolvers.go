package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/subrotokumar/stellerlink-backend/model"
)

// Status is the resolver for the status field.
func (r *mutationResolver) Status(ctx context.Context) (string, error) {
	return "Server is running", nil
}

// Characters is the resolver for the characters field.
func (r *queryResolver) Characters(ctx context.Context, id *int) ([]*model.Character, error) {
	files, err := os.ReadDir("assets/data/characters")
	if err != nil {
		return nil, err
	}

	var jsonResponses []*model.Character

	for _, file := range files {
		if file.IsDir() {
			filePath := filepath.Join("assets/data/characters", file.Name(), "/en.json")
			jsonContent, err := os.ReadFile(filePath)
			if err != nil {
				fmt.Printf("Failed to read %s: %v\n", filePath, err)
				continue
			}

			var jsonData model.Character
			if err := json.Unmarshal(jsonContent, &jsonData); err != nil {
				fmt.Printf("Failed to parse %s: %v\n", filePath, err)
				continue
			}
			if id == nil {
				jsonResponses = append(jsonResponses, &jsonData)
			} else if *id == jsonData.ID {
				jsonResponses = append(jsonResponses, &jsonData)
				break
			}
		}
	}
	return jsonResponses, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
